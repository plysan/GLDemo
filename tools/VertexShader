layout(location = 0) in vec3 vertex_pos_ms;
layout(location = 1) in vec2 vertex_uv_ms;
layout(location = 2) in vec3 vertex_normal_ms;

out vec3 vertex_ws;
out vec3 vertex_normal_cs;
out vec3 vertex_origin_dir_cs;
out vec3 vertex_sun_dir_cs;
out vec2 uv;
noperspective out vec4 scatter_rgba;

uniform mat4 MVP;
uniform mat4 M;
uniform mat4 V;
uniform mat4 notrans_VP;
uniform vec3 sun_ws;
uniform vec3 vertex_offset_ws;
uniform float scatter_height;
uniform int render_target;
uniform sampler3D scatter_texture_sampler;

float atmosphere_radius_square = atmosphere_top_radius * atmosphere_top_radius;
float earth_radius_square = earth_radius * earth_radius;
float atmosphere_thickness = atmosphere_top_radius - earth_radius;
float scatter_texture_size = scatter_texture_3d_size * scatter_texture_4thd_in_3d_size;
float scatter_texture_scale_factor = float(scatter_texture_3d_size - 1) / (scatter_texture_size);
float view_angle_factor = float(scatter_texture_size - 1) / scatter_texture_size;
float scatter_texture_offset = 1.0 / (scatter_texture_size * 2);
int scatter_texture_4thd_size_sub_1 = int(pow(float(scatter_texture_4thd_in_3d_size), 2)) - 1;
float green_pow_coefficient = 1 / pow(green_avg_wlength/red_avg_wlength, 4);
float blue_pow_coefficient = 1 / pow(blue_avg_wlength/red_avg_wlength, 4);

vec4 getScatterAngles(vec3 up_n_cs, vec3 origin_vertex_dir_n_cs, vec3 sun_n_cs, float height_coord_linear, float height_sealevel){
    float view_angle_horizon_cos = -(sqrt(pow(earth_radius+height_sealevel, 2) - pow(earth_radius, 2)) / (earth_radius+height_sealevel));
    float scatter_view_angle_cos = dot(up_n_cs, origin_vertex_dir_n_cs);
    float scatter_view_angle_coord;
    if (scatter_view_angle_cos > view_angle_horizon_cos) {
        scatter_view_angle_coord = (0.5+pow((scatter_view_angle_cos-view_angle_horizon_cos)/(1-view_angle_horizon_cos), 0.2)*0.5) * view_angle_factor + scatter_texture_offset;
    } else {
        scatter_view_angle_coord = (0.5-pow((view_angle_horizon_cos-scatter_view_angle_cos)/(1+view_angle_horizon_cos), 0.2)*0.5) * view_angle_factor + scatter_texture_offset;
    }
    float scatter_sun_angle_vertical = (dot(up_n_cs, sun_n_cs)+1)/2 * scatter_texture_scale_factor + scatter_texture_offset;
    float scatter_sun_angle_horizontal = (dot(cross(up_n_cs, origin_vertex_dir_n_cs), cross(up_n_cs, sun_n_cs))+1)/2 * scatter_texture_scale_factor + scatter_texture_offset;
    return vec4(scatter_sun_angle_horizontal, scatter_sun_angle_vertical, scatter_view_angle_coord, pow(height_coord_linear, 0.5));
}

vec4 texture4D(vec4 scatter_params)
{
    int height_unormalize = int(scatter_params.w * scatter_texture_4thd_size_sub_1);
    float height_middle_offset = scatter_params.w * scatter_texture_4thd_size_sub_1 - height_unormalize;
    float y = float(height_unormalize / scatter_texture_4thd_in_3d_size) / scatter_texture_4thd_in_3d_size;
    float x = float(height_unormalize % scatter_texture_4thd_in_3d_size) / scatter_texture_4thd_in_3d_size;
    vec4 color_0 = texture(scatter_texture_sampler, vec3(scatter_params.x+x, scatter_params.y+y, scatter_params.z));
    height_unormalize++;
    y = float(height_unormalize / scatter_texture_4thd_in_3d_size) / scatter_texture_4thd_in_3d_size;
    x = float(height_unormalize % scatter_texture_4thd_in_3d_size) / scatter_texture_4thd_in_3d_size;
    vec4 color_1 = texture(scatter_texture_sampler, vec3(scatter_params.x+x, scatter_params.y+y, scatter_params.z));
    vec4 result = color_0 * (1.0 - height_middle_offset) + color_1 * height_middle_offset;
    result.rgb = (result.rgb - vec3(color_srgb_offset))/color_srgb_coefficient;
    return result;
}

void main(){

    uv = vertex_uv_ms;

    if (render_target == 0) {
        gl_Position = notrans_VP * vec4(vertex_pos_ms, 1);
    } else {
        gl_Position = MVP * vec4(vertex_pos_ms, 1);
    }

    vertex_ws = (M * vec4(vertex_pos_ms,1)).xyz;

    vec3 vertex_pos_cs = ( V * M * vec4(vertex_pos_ms,1)).xyz;
    vertex_origin_dir_cs = vec3(0,0,0) - vertex_pos_cs;

    vec3 sun_cs = ( V * vec4(sun_ws,1)).xyz;
    vertex_sun_dir_cs = sun_cs + vertex_origin_dir_cs;

    vertex_normal_cs = ( V * M * vec4(vertex_normal_ms,0)).xyz; // Only correct if ModelMatrix does not scale the model ! Use its inverse transpose if not.

    vec3 up_n_cs;
    float height_coord_linear;
    vec3 origin_vertex_dir_n_cs = -normalize(vertex_origin_dir_cs);
    vec3 sun_n_cs = normalize(sun_cs);

    vec3 sphereCenter_pos_cs = (V * vec4(-vertex_offset_ws,1)).xyz;
    vec3 sphereCenter_vertex_cs = vertex_pos_cs - sphereCenter_pos_cs;
    float sphereCenter_vertex_length = length(sphereCenter_vertex_cs);
    vec3 sphereCenter_vertex_normal_cs = normalize(sphereCenter_vertex_cs);
    vec3 vertex_pos_normal_cs = normalize(vertex_pos_cs);
    if (scatter_height > 1.0) {
        height_coord_linear = 1.0;
        float viewer_vertex_sphereCenter_cos = dot(normalize(-sphereCenter_vertex_cs), -normalize(vertex_pos_cs));
        if (render_target == 1) {
            float vertex_sphereCenter_intersec_cos = cos(pi - 2 * acos(viewer_vertex_sphereCenter_cos));
            float camera_offset = length(vertex_pos_cs) - sqrt(2 * atmosphere_radius_square * (1 - vertex_sphereCenter_intersec_cos));
            up_n_cs = normalize(vertex_pos_normal_cs * camera_offset - sphereCenter_pos_cs);
        } else if (render_target == 2) {
            float camera_offset = earth_radius*viewer_vertex_sphereCenter_cos + sqrt(pow(earth_radius*viewer_vertex_sphereCenter_cos, 2) - earth_radius_square + atmosphere_radius_square);
            up_n_cs = normalize(vertex_pos_cs - vertex_pos_normal_cs * camera_offset - sphereCenter_pos_cs);
        }
    } else {
        height_coord_linear = scatter_height;
        up_n_cs = normalize(-sphereCenter_pos_cs);
    }
    vec4 scatter_rgba_first = texture4D(getScatterAngles(up_n_cs, origin_vertex_dir_n_cs, sun_n_cs, height_coord_linear, height_coord_linear*atmosphere_thickness));
    scatter_rgba = scatter_rgba_first;
    scatter_rgba = clamp(scatter_rgba, vec4(0), vec4(1));
    scatter_rgba.a = clamp(max(scatter_rgba.r, max(scatter_rgba.g, scatter_rgba.b)), 0, 1);
    if (scatter_rgba.a > 0) {
        scatter_rgba.rgb /= scatter_rgba.a;
    }
    if (render_target == 2) {
        up_n_cs = sphereCenter_vertex_normal_cs;
        float height_sealevel = clamp(sphereCenter_vertex_length - earth_radius, 0, atmosphere_thickness);
        height_coord_linear = height_sealevel/atmosphere_thickness;

        vec4 scatter_rgba_second = texture4D(getScatterAngles(up_n_cs, origin_vertex_dir_n_cs, sun_n_cs, height_coord_linear, height_sealevel));
        float first_second_optical_depth = scatter_rgba_first.a / scatter_rgba_second.a;
        vec3 scatter_rgba_offset = vec3(scatter_rgba_second.r * first_second_optical_depth,
                                        scatter_rgba_second.g * pow(first_second_optical_depth, green_pow_coefficient),
                                        scatter_rgba_second.b * pow(first_second_optical_depth, blue_pow_coefficient));
        scatter_rgba.rgb = clamp(scatter_rgba_first.rgb - scatter_rgba_offset, vec3(0), vec3(1));
        scatter_rgba.a = clamp(max(scatter_rgba.r, max(scatter_rgba.g, scatter_rgba.b)), 0, 1);
        if(scatter_rgba.a > 0) {
            scatter_rgba.rgb /= scatter_rgba.a;
        }
    }

}

