in vec3 vertex_ws;
in vec3 vertex_normal_cs;
in vec3 vertex_origin_dir_cs;
in vec3 vertex_sun_dir_cs;
in vec2 uv;
in vec4 scatter_params;
in vec4 scatter_params_terrain;

out vec3 color;

uniform vec3 sun_ws;
uniform sampler2D terrain_texture_sampler;
uniform sampler3D scatter_texture_sampler;
uniform int render_target;

vec4 texture4D(vec4 scatter_params)
{
    int height_unormalize = int(scatter_params.w * 7);
    float height_middle_offset = scatter_params.w * 7 - height_unormalize;
    int xy_remainder = height_unormalize % 4;
    float z = float(height_unormalize / 4) / 2;
    float y = float(xy_remainder / 2) / 2;
    float x = float(xy_remainder % 2) / 2;
    vec4 color_0 = texture(scatter_texture_sampler, vec3(scatter_params.x+x, scatter_params.y+y, scatter_params.z+z));
    height_unormalize++;
    xy_remainder = height_unormalize % 4;
    z = float(height_unormalize / 4) / 2;
    y = float(xy_remainder / 2) / 2;
    x = float(xy_remainder % 2) / 2;
    vec4 color_1 = texture(scatter_texture_sampler, vec3(scatter_params.x+x, scatter_params.y+y, scatter_params.z+z));
    return color_0 * (1.0 - height_middle_offset) + color_1 * height_middle_offset;
}

void main()
{
    vec3 sun_color = vec3(1,1,1);
    float sun_power = 200000000.0f;

    vec4 terrain_rgba = texture(terrain_texture_sampler, uv);
    vec3 terrain_diffuse = vec3(0.01, 0.01, 0.01) + terrain_rgba.rgb;
    vec3 terrain_ambient = vec3(0.4, 0.4, 0.4) * terrain_diffuse;
    vec3 terrain_specular = vec3(1.0-terrain_rgba.a, 1.0-terrain_rgba.a, 1.0-terrain_rgba.a);
    vec4 scatter_rgba = texture4D(scatter_params);
    if(render_target == 1){
        scatter_rgba -= texture4D(scatter_params_terrain);
    }

    float sun_vertex_distance = length( sun_ws - vertex_ws );

    vec3 vertex_normal_normal_cs = normalize( vertex_normal_cs );
    vec3 vertex_sun_dir_normal_cs = normalize( vertex_sun_dir_cs );
    // Cosine of the angle between the normal and the light direction,
    // clamped above 0
    //  - light is at the vertical of the triangle -> 1
    //  - light is perpendicular to the triangle -> 0
    //  - light is behind the triangle -> 0
    float cos_sun_vertex_normal = clamp( dot( vertex_normal_normal_cs,vertex_sun_dir_normal_cs ), 0,1 );

    vec3 vertex_origin_dir_normal_cs = normalize(vertex_origin_dir_cs);
    vec3 reflect_sun_vertex_cs = reflect(-vertex_sun_dir_normal_cs, vertex_normal_normal_cs);
    // Cosine of the angle between the Eye vector and the Reflect vector,
    // clamped to 0
    //  - Looking into the reflection -> 1
    //  - Looking elsewhere -> < 1
    float cos_origin_vertex_reflect = clamp( dot( vertex_origin_dir_normal_cs,reflect_sun_vertex_cs ), 0,1 );

    float factor;
    if(render_target == 1){ // temperate means to mix terrain color with scatter color
        factor = scatter_rgba.g;
    } else {
        factor = 1;
    }
    color =
        scatter_rgba.rgb*factor + (1-factor) * (terrain_ambient +
        terrain_diffuse * sun_color * sun_power * cos_sun_vertex_normal / (sun_vertex_distance) +
        terrain_specular * sun_color * sun_power * pow(cos_origin_vertex_reflect,7) / (sun_vertex_distance));
}
